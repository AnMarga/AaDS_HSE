# Префикс-функция

## A. Префикс-функция

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256Mb
  
  ввод: стандартный ввод или input.txt
  
  вывод: стандартный вывод или output.txt
  
  Дана непустая строка _S_, длина которой _N_ не превышает 10^6. Будем считать, что элементы строки нумеруются от 0 до _N_-1. 
  Требуется для всех _i_ от 0 до _N_-1 вычислить её префикс-функцию.

### Формат ввода

Одна строка длины _N_, 0 < _N_ ≤ 10^6, состоящая из маленьких латинских букв.

### Формат вывода

Выведите _N_ чисел — значения префикс-функции для каждой позиции, разделённые пробелом.

### Пример

**Ввод**
```c++
abracadabra
```
**Вывод**
```c++
0 0 0 1 0 1 0 1 2 3 4 
```

### [Решение](1_A.cpp)


## B. Основание строки

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256Mb
  
  ввод: стандартный ввод или input.txt
  
  вывод: стандартный вывод или output.txt
  
Строка _S_ была записана много раз подряд, после чего от получившейся строки взяли префикс и дали вам. Ваша задача определить минимально возможную длину исходной строки _S_.

### Формат ввода

В первой и единственной строке входного файла записана строка, которая содержит только латинские буквы, длина строки не превышает _50000_ символов.

### Формат вывода

Выведите ответ на задачу.

### Пример 1

**Ввод**
```c++
zzz
```
**Вывод**
```c++
1
```

### Пример 2

**Ввод**
```c++
bcabcab
```
**Вывод**
```c++
3
```

### [Решение](1_B.cpp)


## C. Z-функция

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256Mb
  
  ввод: стандартный ввод или input.txt
  
  вывод: стандартный вывод или output.txt
  
Дана непустая строка _S_, длина которой N не превышает _10^6_. Будем считать, что элементы строки нумеруются от 0 до _N_-1.
Вычислите _z_-функцию _z[i]_ для всех _i_ от 0 до _N_-1. _z[i]_ определяется как максимальная длина подстроки, начинающейся с позиции _i_ и совпадающей с префиксом всей строки. _z[0] = 0_

### Формат ввода

Одна строка длины _N_, 0 < _N_ ≤ 10^6, состоящая из прописных латинских букв.

### Формат вывода

Выведите _N_ чисел — значения _z_-функции для каждой позиции, разделённые пробелом.

### Пример

**Ввод**
```c++
abracadabra
```
**Вывод**
```c++
 0 0 0 1 0 1 0 4 0 0 1 
 ```
 

### [Решение](1_C.cpp)


## D. Неточное совпадение

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256Mb
  
  ввод: стандартный ввод или input.txt
  
  вывод: стандартный вывод или output.txt
  
Даны строки _p_ и _t_. Требуется найти все вхождения строки _p_ в строку _t_ в качестве подстроки с точностью до возможного несовпадения одного символа.

### Формат ввода

Первая строка входного файла содержит _p_, вторая — _t_ (1 ≤ |_p_|, |_t_| ≤ 10^6). Строки состоят из букв латинского алфавита.

### Формат вывода

В первой строке выведите количество вхождений строки _p_ в строку _t_. Во второй строке выведите в возрастающем порядке номера символов строки _t_, с которых начинаются вхождения _p_. Символы нумеруются с единицы.

### Пример

**Ввод**
```c++
aaaa
Caaabdaaaa
```
**Вывод**
```c++
4
1 2 6 7
 ```

### [Решение]()


## E. Дуэт на клавиатуре

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 Mb
  
  ввод: стандартный ввод или input.txt
  
  вывод: стандартный вывод или output.txt
  
В 2030 году Очень Известная Компания выпустила новую клавиатуру. Разработчики решили избавиться от всех ненужных кнопок и оставить только кнопки с первыми _A_ буквами латинского алфавита. Новая клавиатура пользуется большой популярностью, поэтому Петя решил научиться печатать на ней свое любимое слово (оно не содержит букв, отличных от первых _A_ букв латинского алфавита).

Петя считает, что он научился, когда на экране можно будет увидеть его любимое слово целиком (то есть найдется последовательность подряд идущих букв, образующих его любимое слово). Например, если Петино любимое слово — «apple», и на экране написано «pineappled», то любимое слово увидеть можно, а если на экране написано «mapplicе», то нельзя. Петя запустил текстовый редактор, и пытается, совершив как можно меньше нажатий на клавиши, добиться появления своего любимого слова.

У Пети есть друг Вася, который хочет, чтобы Петя, напротив, совершил как можно больше нажатий на клавиши — так он лучше научится. В любые моменты (как до того, как Петя начал набирать текст, так и между нажатиями Пети на клавиши) Вася может отпихивать Петю от клавиатуры и печатать на ней что угодно. При этом ни Петя, ни Вася не могут стирать уже напечатанные символы. Суммарно Вася может сделать не более _K_ нажатий на клавиши (не обязательно подряд), после этого Петя выгонит его из комнаты, и Вася больше никак не будет участвовать в процессе обучения.

Друзья видят, что написано на экране, и знают, сколько клавиш уже нажал каждый из них. Исходя из этого и Петя, и Вася действуют наиболее оптимально.

Напишите программу, которая определит общее количество Петиных нажатий на клавиши, после которого он гарантированно увидит свое любимое слово.

Указание. Постройте автомат КМП и реализуйте динамическое программирование на его вершинах.

### Формат ввода

В первой строке входного файла содержатся три целых числа: _N_, _A_, _K_ — длина любимого слова Пети, количество кнопок на клавиатуре и максимальное количество нажатий кнопок Васей соответственно (_1 ≤ N ≤ 100 000, 1 ≤ A ≤ 26, 1 ≤ K ≤ 10^9_). В следующей строке содержится слово длины _N_, состоящее из строчных латинских букв — любимое слово Пети. Слово завершает перевод строки.

### Формат вывода

Выведите одно число — искомое количество нажатий клавиш.

### Пример 1

**Ввод**
```c++
2 1 2
aa
```
**Вывод**
```c++
2
 ```

### Пример 2
 
**Ввод**
```c++
3 4 3
abc
```
**Вывод**
```c++
9
 ```

### Пример 3

**Ввод**
```c++
3 2 1
aab
```
**Вывод**
```c++
4
 ```

### [Решение]()

